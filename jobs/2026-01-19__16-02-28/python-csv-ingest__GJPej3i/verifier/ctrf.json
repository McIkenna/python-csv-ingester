{
    "results": {
        "tool": {
            "name": "pytest",
            "version": "8.4.1"
        },
        "summary": {
            "tests": 26,
            "passed": 0,
            "failed": 26,
            "skipped": 0,
            "pending": 0,
            "other": 0,
            "start": 1768860619.4270322,
            "stop": 1768860619.775309
        },
        "tests": [
            {
                "name": "test_outputs.py::test_should_detect_utf8_encoding",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.004060583001773921,
                "start": 1768860619.4646385,
                "stop": 1768860619.4799416,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data_two = '/tests/test2_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_should_detect_utf8_encoding(mock_test_data_two, solve_sh_path):\n        \"\"\"Test for encoding detection\"\"\"\n        stdout, stderr, returncode = run_bash_command(\n                \"encoding-detection\",\n                f'\"{mock_test_data_two}\"',\n                solve_sh_path\n            )\n        assert returncode == 0\n>       assert \"utf\" in stdout.lower() or \"utf-8\" in stdout.lower()\nE       AssertionError: assert ('utf' in '' or 'utf-8' in '')\nE        +  where '' = <built-in method lower of str object at 0xffff904f1188>()\nE        +    where <built-in method lower of str object at 0xffff904f1188> = ''.lower\nE        +  and   '' = <built-in method lower of str object at 0xffff904f1188>()\nE        +    where <built-in method lower of str object at 0xffff904f1188> = ''.lower\n\n/tests/test_outputs.py:203: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_should_detect_latin_encoding",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.01547529099843814,
                "start": 1768860619.4800777,
                "stop": 1768860619.5008707,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_latin1_data = '/tests/latin1_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_should_detect_latin_encoding(mock_latin1_data, solve_sh_path):\n        \"\"\"Test for encoding detection\"\"\"\n        stdout, stderr, returncode = run_bash_command(\n                \"encoding-detection\",\n                f'\"{mock_latin1_data}\"',\n                solve_sh_path\n            )\n        assert returncode == 0\n>       assert \"latin\" in stdout.lower() or \"latin-1\" in stdout.lower()\nE       AssertionError: assert ('latin' in '' or 'latin-1' in '')\nE        +  where '' = <built-in method lower of str object at 0xffff904f1188>()\nE        +    where <built-in method lower of str object at 0xffff904f1188> = ''.lower\nE        +  and   '' = <built-in method lower of str object at 0xffff904f1188>()\nE        +    where <built-in method lower of str object at 0xffff904f1188> = ''.lower\n\n/tests/test_outputs.py:213: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_should_detect_encoding_nonexistent_file",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.003553374999683001,
                "start": 1768860619.5010107,
                "stop": 1768860619.5098584,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "solve_sh_path = 'solution/solve.sh'\n\n    def test_should_detect_encoding_nonexistent_file(solve_sh_path):\n        \"\"\"Test with non-existent file\"\"\"\n        fake_file = os.path.join(TEST_DIR, \"nonexistent.csv\")\n        stdout, stderr, returncode = run_bash_command(\n            \"encoding-detection\",\n            f'\"{fake_file}\"',\n            solve_sh_path\n        )\n>       assert returncode != 0\nE       assert 0 != 0\n\n/tests/test_outputs.py:226: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_standardize_spaces_col_name",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0028431249993445817,
                "start": 1768860619.5099678,
                "stop": 1768860619.5180213,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "solve_sh_path = 'solution/solve.sh'\n\n    def test_standardize_spaces_col_name(solve_sh_path):\n            \"\"\"Test standardizing column with spaces\"\"\"\n            stdout, stderr, returncode = run_bash_command(\n                \"name-standardization\",\n                '\"Order Date\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n>           assert stdout.strip() == \"order_date\"\nE           AssertionError: assert '' == 'order_date'\nE             \nE             - order_date\n\n/tests/test_outputs.py:236: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_standardize_any_special_chars",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0029117499998392304,
                "start": 1768860619.5181286,
                "stop": 1768860619.5263338,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "solve_sh_path = 'solution/solve.sh'\n\n    def test_standardize_any_special_chars(solve_sh_path):\n            \"\"\"Test standardizing column with special characters\"\"\"\n            stdout, stderr, returncode = run_bash_command(\n                \"name-standardization\",\n                '\"Price $!!\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n>           assert stdout.strip() == \"price\"\nE           AssertionError: assert '' == 'price'\nE             \nE             - price\n\n/tests/test_outputs.py:246: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_standardize_any_casing",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.003349708997120615,
                "start": 1768860619.5264356,
                "stop": 1768860619.5347486,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "solve_sh_path = 'solution/solve.sh'\n\n    def test_standardize_any_casing(solve_sh_path):\n            \"\"\"Test standardizing column with special characters\"\"\"\n            stdout, stderr, returncode = run_bash_command(\n                \"name-standardization\",\n                '\"ProductPrice\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n>           assert stdout.strip() == \"product_price\"\nE           AssertionError: assert '' == 'product_price'\nE             \nE             - product_price\n\n/tests/test_outputs.py:256: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_detect_numeric_column",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0028089580009691417,
                "start": 1768860619.534872,
                "stop": 1768860619.5429726,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_detect_numeric_column(mock_test_data, solve_sh_path):\n            \"\"\"Test detection of numeric column\"\"\"\n            stdout, stderr, returncode = run_bash_command(\n                \"type-detection\",\n                f'\"{mock_test_data}\" \"Product Price $\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n>           assert stdout.strip() == \"numeric\"\nE           AssertionError: assert '' == 'numeric'\nE             \nE             - numeric\n\n/tests/test_outputs.py:270: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_detect_date_column",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.002854291000403464,
                "start": 1768860619.5430808,
                "stop": 1768860619.5511475,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data_two = '/tests/test2_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_detect_date_column(mock_test_data_two, solve_sh_path):\n        \"\"\"Test detection of date column\"\"\"\n        stdout, stderr, returncode = run_bash_command(\n            \"type-detection\",\n            f'\"{mock_test_data_two}\" \"Last Restock\"',\n            solve_sh_path\n        )\n        assert returncode == 0\n>       assert stdout.strip() == \"date\"\nE       AssertionError: assert '' == 'date'\nE         \nE         - date\n\n/tests/test_outputs.py:280: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_detect_categorical_column",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0033066679989133263,
                "start": 1768860619.5512521,
                "stop": 1768860619.5601254,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data_two = '/tests/test2_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_detect_categorical_column(mock_test_data_two, solve_sh_path):\n        \"\"\"Test detection of categorical column\"\"\"\n        stdout, stderr, returncode = run_bash_command(\n            \"type-detection\",\n            f'\"{mock_test_data_two}\" \"Supplier\"',\n            solve_sh_path\n        )\n        assert returncode == 0\n>       assert stdout.strip() == \"categorical\"\nE       AssertionError: assert '' == 'categorical'\nE         \nE         - categorical\n\n/tests/test_outputs.py:290: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_detect_nonexistent_column",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.006335207999654813,
                "start": 1768860619.5602348,
                "stop": 1768860619.5718653,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data_three = '/tests/test3_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_detect_nonexistent_column(mock_test_data_three, solve_sh_path):\n        \"\"\"Test with non-existent column\"\"\"\n        stdout, stderr, returncode = run_bash_command(\n            \"type-detection\",\n            f'\"{mock_test_data_three}\" \"NonExistent\"',\n            solve_sh_path\n        )\n>       assert returncode == 1\nE       assert 0 == 1\n\n/tests/test_outputs.py:299: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_parse_iso_dates",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.004197165999357821,
                "start": 1768860619.5719874,
                "stop": 1768860619.5838187,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_parse_iso_dates(mock_test_data, solve_sh_path):\n            \"\"\"Test parsing of ISO format dates\"\"\"\n            stdout, stderr, returncode = run_bash_command(\n                \"date-parsing\",\n                f'\"{mock_test_data}\" \"Order Date\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n            # Should return JSON array\n>           dates = extract_json_from_output(stdout)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:316: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_parse_mixed_date_formats",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.008730166999157518,
                "start": 1768860619.5839405,
                "stop": 1768860619.600856,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data_two = '/tests/test2_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_parse_mixed_date_formats( mock_test_data_two, solve_sh_path):\n        \"\"\"Test parsing of mixed date formats\"\"\"\n        stdout, stderr, returncode = run_bash_command(\n            \"date-parsing\",\n            f'\"{mock_test_data_two}\" \"Last Restock\"',\n            solve_sh_path\n        )\n        assert returncode == 0\n>       dates = extract_json_from_output(stdout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:328: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_clip_numeric_outliers",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.00519620800150733,
                "start": 1768860619.6009974,
                "stop": 1768860619.6141417,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_clip_numeric_outliers(mock_test_data, solve_sh_path):\n        print('solve_sh_path:', solve_sh_path)\n        \"\"\"Test clipping of numeric outliers\"\"\"\n        stdout, stderr, returncode = run_bash_command(\n            \"outlier-truncate\",\n            f'\"{mock_test_data}\" \"Total Amount\"',\n            solve_sh_path\n        )\n        assert returncode == 0\n>       result = extract_json_from_output(stdout)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:346: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_clean_single_dataframe",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.004257207998307422,
                "start": 1768860619.6143525,
                "stop": 1768860619.624567,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_clean_single_dataframe(mock_test_data, solve_sh_path):\n        \"\"\"Test cleaning of entire dataframe\"\"\"\n        output_file = os.path.join(TEST_DIR, 'cleaned_output.csv')\n        if os.path.exists(output_file):\n            os.remove(output_file)\n    \n        stdout, stderr, returncode = run_bash_command(\n            \"dataframe-cleaning\",\n            f'\"{mock_test_data}\" \"{output_file}\"',\n            solve_sh_path\n        )\n        assert returncode == 0\n>       assert os.path.exists(output_file)\nE       AssertionError: assert False\nE        +  where False = <function exists at 0xffff8fdcf420>('/tests/cleaned_output.csv')\nE        +    where <function exists at 0xffff8fdcf420> = <module 'posixpath' (frozen)>.exists\nE        +      where <module 'posixpath' (frozen)> = os.path\n\n/tests/test_outputs.py:373: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_cleaned_columns_standardized",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.003154543001073762,
                "start": 1768860619.6249654,
                "stop": 1768860619.640187,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_cleaned_columns_standardized(mock_test_data, solve_sh_path):\n            \"\"\"Test that cleaned CSV has standardized column names\"\"\"\n            output_file = os.path.join(TEST_DIR, 'cleaned_output.csv')\n            stdout, stderr, returncode = run_bash_command(\n                \"dataframe-cleaning\",\n                f'\"{mock_test_data}\" \"{output_file}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n>           result = extract_json_from_output(stdout)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:392: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_consolidate_dataframes",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0032266660000459524,
                "start": 1768860619.6402936,
                "stop": 1768860619.651153,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv'\nmock_test_data_two = '/tests/test2_data.csv'\nmock_test_data_three = '/tests/test3_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_consolidate_dataframes(mock_test_data, mock_test_data_two, mock_test_data_three, solve_sh_path):\n        \"\"\"Test consolidation of multiple dataframes\"\"\"\n        output_file = os.path.join(TEST_DIR, 'consolidated_output.csv')\n    \n        stdout, stderr, returncode = run_bash_command(\n            \"dataframe-consolidation\",\n            f'\"{output_file}\" \"{mock_test_data}\" \"{mock_test_data_two}\" \"{mock_test_data_three}\"',\n            solve_sh_path\n        )\n        assert returncode == 0\n>       result = extract_json_from_output(stdout)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:418: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_process_full_pipeline",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.002911958001277526,
                "start": 1768860619.6512573,
                "stop": 1768860619.661911,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv'\nmock_test_data_two = '/tests/test2_data.csv'\nmock_test_data_three = '/tests/test3_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_process_full_pipeline(mock_test_data, mock_test_data_two, mock_test_data_three, solve_sh_path):\n            \"\"\"Test the complete processing pipeline\"\"\"\n            output_file = os.path.join(TEST_DIR, \"final_output.csv\")\n            log_file = os.path.join(TEST_DIR, \"process_log.json\")\n    \n            stdout, stderr, returncode = run_bash_command(\n                \"file-processing\",\n                f'\"{output_file}\" \"{log_file}\" \"{mock_test_data}\" \"{mock_test_data_two}\" \"{mock_test_data_three}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n            # Parse the log output\n>           log = extract_json_from_output(stdout)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:444: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_process_log_contains_operations",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.006552001003001351,
                "start": 1768860619.6620243,
                "stop": 1768860619.6761377,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data_two = '/tests/test2_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_process_log_contains_operations(mock_test_data_two,solve_sh_path):\n            \"\"\"Test that processing log contains expected operations\"\"\"\n            output_file = os.path.join(TEST_DIR, \"output.csv\")\n            log_file = os.path.join(TEST_DIR, \"log.json\")\n    \n            stdout, stderr, returncode = run_bash_command(\n                \"file-processing\",\n                f'\"{output_file}\" \"{log_file}\" \"{mock_test_data_two}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n>           log = extract_json_from_output(stdout)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:471: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_get_existing_operations",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0062158319997251965,
                "start": 1768860619.6762424,
                "stop": 1768860619.6903822,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_get_existing_operations(mock_test_data, solve_sh_path):\n    \n            output_file = os.path.join(TEST_DIR, \"output.csv\")\n            log_file = os.path.join(TEST_DIR, \"log.json\")\n    \n            # First, run processing to generate log\n            stdout, stderr, returncode = run_bash_command(\n                \"file-processing\",\n                f'\"{output_file}\" \"{log_file}\" \"{mock_test_data}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n            # Now, get existing operations\n            stdout, stderr, returncode = run_bash_command(\n                \"get-operations\",\n                f'\"{log_file}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n>           operations = extract_json_from_output(stdout)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_get_median_for_missing",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.004166291999354144,
                "start": 1768860619.6904836,
                "stop": 1768860619.7025566,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_get_median_for_missing(mock_test_data, solve_sh_path):\n        \"\"\"Test to replace missing categorical values with 'Unknown'\"\"\"\n        output_file = os.path.join(TEST_DIR, 'output.csv')\n        log_file = os.path.join(TEST_DIR, \"log.json\")\n        if os.path.exists(output_file):\n            os.remove(output_file)\n        with open(mock_test_data, \"r\", encoding=\"utf-8\") as f:\n            reader = csv.reader(f)\n            headers = next(reader)\n            assert \"Product Price $\" in headers\n            empty_data_idx = headers.index(\"Product Price $\")\n            next(reader)\n            next(reader)\n            third_row = next(reader)\n            # test the value in the first data row\n            assert third_row[empty_data_idx] is None or third_row[empty_data_idx] == \"\"\n    \n        stdout, stderr, returncode = run_bash_command(\n            \"file-processing\",\n           f'\"{output_file}\" \"{log_file}\" \"{mock_test_data}\"',\n            solve_sh_path\n        )\n        assert returncode == 0\n>       log = extract_json_from_output(stdout)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:534: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_get_unknown_for_missing",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0025815839999268064,
                "start": 1768860619.7030337,
                "stop": 1768860619.713499,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data_two = '/tests/test2_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_get_unknown_for_missing(mock_test_data_two, solve_sh_path):\n        \"\"\"Test to replace missing categorical values with 'Unknown'\"\"\"\n        output_file = os.path.join(TEST_DIR, 'output.csv')\n        log_file = os.path.join(TEST_DIR, \"log.json\")\n        if os.path.exists(output_file):\n            os.remove(output_file)\n        with open(mock_test_data_two, \"r\", encoding=\"utf-8\") as f:\n            reader = csv.reader(f)\n            headers = next(reader)\n            assert \"Supplier\" in headers\n            empty_data_idx = headers.index(\"Supplier\")\n            # test the value in the first data row\n            first_row = next(reader)\n            assert first_row[empty_data_idx] == \"\"\n    \n        stdout, stderr, returncode = run_bash_command(\n            \"file-processing\",\n           f'\"{output_file}\" \"{log_file}\" \"{mock_test_data_two}\"',\n            solve_sh_path\n        )\n        assert returncode == 0\n>       log = extract_json_from_output(stdout)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:582: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_get_cleaning_log",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.006225084000107017,
                "start": 1768860619.7140741,
                "stop": 1768860619.7281854,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_get_cleaning_log(mock_test_data, solve_sh_path):\n            \"\"\"Test retrieval of cleaning log\"\"\"\n            output_file = os.path.join(TEST_DIR, \"output.csv\")\n            log_file = os.path.join(TEST_DIR, \"log.json\")\n    \n            # First, run processing to generate log\n            stdout, stderr, returncode = run_bash_command(\n                \"file-processing\",\n                f'\"{output_file}\" \"{log_file}\" \"{mock_test_data}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n            # Now, get cleaning log\n            stdout, stderr, returncode = run_bash_command(\n                \"cleaning-log\",\n                f'\"{log_file}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n>           cleaning_log = extract_json_from_output(stdout)\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:631: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_get_cleaning_log_nonexistent_file",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.004958751000231132,
                "start": 1768860619.728302,
                "stop": 1768860619.7410386,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "solve_sh_path = 'solution/solve.sh'\n\n    def test_get_cleaning_log_nonexistent_file(solve_sh_path):\n            \"\"\"Test retrieval of cleaning log from non-existent file\"\"\"\n            fake_log_file = os.path.join(TEST_DIR, \"nonexistent_log.json\")\n    \n            stdout, stderr, returncode = run_bash_command(\n                \"cleaning-log\",\n                f'\"{fake_log_file}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n>           error_response = extract_json_from_output(stdout)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:651: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_get_csv_summary",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.005574457998591242,
                "start": 1768860619.741148,
                "stop": 1768860619.754323,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv', solve_sh_path = 'solution/solve.sh'\n\n    def test_get_csv_summary(mock_test_data, solve_sh_path):\n    \n            # First, run processing to generate log\n            stdout, stderr, returncode = run_bash_command(\n                \"csv-summary\",\n                f'\"{mock_test_data}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n>           summary = extract_json_from_output(stdout)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:668: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_summary_shows_missing_values",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0027022499998565763,
                "start": 1768860619.754428,
                "stop": 1768860619.7648191,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data_two = '/tests/test2_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_summary_shows_missing_values( mock_test_data_two, solve_sh_path):\n            \"\"\"Test that summary correctly identifies missing values\"\"\"\n            stdout, stderr, returncode = run_bash_command(\n                \"csv-summary\",\n                f'\"{mock_test_data_two}\"',\n                solve_sh_path\n            )\n            assert returncode == 0\n    \n>           summary = extract_json_from_output(stdout)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:691: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_full_workflow",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.002868167000997346,
                "start": 1768860619.76492,
                "stop": 1768860619.775203,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "mock_test_data = '/tests/test_data.csv'\nmock_test_data_two = '/tests/test2_data.csv'\nmock_test_data_three = '/tests/test3_data.csv'\nsolve_sh_path = 'solution/solve.sh'\n\n    def test_full_workflow(mock_test_data, mock_test_data_two,  mock_test_data_three,\n                            solve_sh_path):\n        \"\"\"Test a complete workflow using multiple functions\"\"\"\n    \n        # 1. Get summary of input files\n        stdout1, _, _ = run_bash_command(\n            \"csv-summary\",\n            f'\"{mock_test_data}\"',\n            solve_sh_path\n        )\n>       summary1 = extract_json_from_output(stdout1)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:713: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\noutput = ''\n\n    def extract_json_from_output(output):\n        \"\"\"Extract JSON from output that may contain other text\"\"\"\n        try:\n            return json.loads(output)\n        except json.JSONDecodeError:\n            pass\n    \n        # Try to find JSON starting with { or [\n        for start_char in ['{', '[']:\n            start_idx = output.find(start_char)\n            if start_idx != -1:\n                depth = 0\n                end_char = '}' if start_char == '{' else ']'\n    \n                for i in range(start_idx, len(output)):\n                    if output[i] == start_char:\n                        depth += 1\n                    elif output[i] == end_char:\n                        depth -= 1\n                        if depth == 0:\n                            json_str = output[start_idx:i+1]\n                            try:\n                                return json.loads(json_str)\n                            except json.JSONDecodeError:\n                                continue\n    \n>       raise json.JSONDecodeError(\"No valid JSON found in output\", output, 0)\nE       json.decoder.JSONDecodeError: No valid JSON found in output: line 1 column 1 (char 0)\n\n/tests/test_outputs.py:58: JSONDecodeError",
                "message": "The test failed in the call phase"
            }
        ]
    }
}